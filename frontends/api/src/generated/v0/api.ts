/* tslint:disable */
/* eslint-disable */
/**
 * MIT Open API
 * MIT public API
 *
 * The version of the OpenAPI document: 0.0.1 (v0)
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration"
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios"
import globalAxios from "axios"
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common"
import type { RequestArgs } from "./base"
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base"

/**
 * Serializer for FeedImage
 * @export
 * @interface FeedImage
 */
export interface FeedImage {
  /**
   *
   * @type {number}
   * @memberof FeedImage
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof FeedImage
   */
  url?: string
  /**
   *
   * @type {string}
   * @memberof FeedImage
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof FeedImage
   */
  alt?: string
}
/**
 * FeedSource serializer
 * @export
 * @interface FeedSource
 */
export interface FeedSource {
  /**
   *
   * @type {number}
   * @memberof FeedSource
   */
  id: number
  /**
   *
   * @type {FeedImage}
   * @memberof FeedSource
   */
  image: FeedImage
  /**
   *
   * @type {string}
   * @memberof FeedSource
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof FeedSource
   */
  url: string
  /**
   *
   * @type {string}
   * @memberof FeedSource
   */
  description?: string
  /**
   *
   * @type {FeedTypeEnum}
   * @memberof FeedSource
   */
  feed_type: FeedTypeEnum
}

/**
 * * `news` - News * `events` - Events
 * @export
 * @enum {string}
 */

export const FeedTypeEnum = {
  News: "news",
  Events: "events",
} as const

export type FeedTypeEnum = (typeof FeedTypeEnum)[keyof typeof FeedTypeEnum]

/**
 * Serializer for FieldChannel
 * @export
 * @interface FieldChannel
 */
export interface FieldChannel {
  /**
   *
   * @type {string}
   * @memberof FieldChannel
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof FieldChannel
   */
  title: string
  /**
   *
   * @type {any}
   * @memberof FieldChannel
   */
  about: any | null
  /**
   *
   * @type {string}
   * @memberof FieldChannel
   */
  public_description: string
  /**
   *
   * @type {Array<Subfield>}
   * @memberof FieldChannel
   */
  subfields: Array<Subfield>
  /**
   *
   * @type {FieldChannelFeaturedList}
   * @memberof FieldChannel
   */
  featured_list: FieldChannelFeaturedList | null
  /**
   *
   * @type {Array<LearningPathPreview>}
   * @memberof FieldChannel
   */
  lists: Array<LearningPathPreview>
  /**
   * Get the avatar image URL
   * @type {string}
   * @memberof FieldChannel
   */
  avatar?: string | null
  /**
   * Get the avatar image medium URL
   * @type {string}
   * @memberof FieldChannel
   */
  avatar_medium: string | null
  /**
   * Get the avatar image small URL
   * @type {string}
   * @memberof FieldChannel
   */
  avatar_small: string | null
  /**
   * Get the banner image URL
   * @type {string}
   * @memberof FieldChannel
   */
  banner?: string | null
  /**
   *
   * @type {number}
   * @memberof FieldChannel
   */
  widget_list: number | null
  /**
   *
   * @type {string}
   * @memberof FieldChannel
   */
  updated_on: string
  /**
   *
   * @type {string}
   * @memberof FieldChannel
   */
  created_on: string
  /**
   *
   * @type {number}
   * @memberof FieldChannel
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof FieldChannel
   */
  ga_tracking_id: string
  /**
   * Return true if user is a moderator for the channel
   * @type {boolean}
   * @memberof FieldChannel
   */
  is_moderator: boolean
}
/**
 * Write serializer for FieldChannel. Uses primary keys for referenced objects during requests, and delegates to FieldChannelSerializer for responses.
 * @export
 * @interface FieldChannelCreateRequest
 */
export interface FieldChannelCreateRequest {
  /**
   *
   * @type {string}
   * @memberof FieldChannelCreateRequest
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof FieldChannelCreateRequest
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof FieldChannelCreateRequest
   */
  public_description?: string
  /**
   *
   * @type {Array<string>}
   * @memberof FieldChannelCreateRequest
   */
  subfields?: Array<string>
  /**
   * Learng path featured in this field.
   * @type {number}
   * @memberof FieldChannelCreateRequest
   */
  featured_list?: number | null
  /**
   * Learng paths in this field.
   * @type {Array<number>}
   * @memberof FieldChannelCreateRequest
   */
  lists?: Array<number>
  /**
   *
   * @type {File}
   * @memberof FieldChannelCreateRequest
   */
  avatar?: File | null
  /**
   *
   * @type {File}
   * @memberof FieldChannelCreateRequest
   */
  banner?: File | null
  /**
   *
   * @type {any}
   * @memberof FieldChannelCreateRequest
   */
  about?: any | null
}
/**
 * Learning path featured in this field.
 * @export
 * @interface FieldChannelFeaturedList
 */
export interface FieldChannelFeaturedList {
  /**
   *
   * @type {string}
   * @memberof FieldChannelFeaturedList
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof FieldChannelFeaturedList
   */
  url?: string | null
  /**
   *
   * @type {number}
   * @memberof FieldChannelFeaturedList
   */
  id: number
}
/**
 * Serializer for moderators
 * @export
 * @interface FieldModerator
 */
export interface FieldModerator {
  /**
   * Returns the name for the moderator
   * @type {string}
   * @memberof FieldModerator
   */
  moderator_name?: string
  /**
   * Get the email from the associated user
   * @type {string}
   * @memberof FieldModerator
   */
  email?: string
  /**
   * Get the full name of the associated user
   * @type {string}
   * @memberof FieldModerator
   */
  full_name: string
}
/**
 * Serializer for moderators
 * @export
 * @interface FieldModeratorRequest
 */
export interface FieldModeratorRequest {
  /**
   * Returns the name for the moderator
   * @type {string}
   * @memberof FieldModeratorRequest
   */
  moderator_name?: string
  /**
   * Get the email from the associated user
   * @type {string}
   * @memberof FieldModeratorRequest
   */
  email?: string
}
/**
 * Serializer for a minimal preview of Learning Paths
 * @export
 * @interface LearningPathPreview
 */
export interface LearningPathPreview {
  /**
   *
   * @type {string}
   * @memberof LearningPathPreview
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof LearningPathPreview
   */
  url?: string | null
  /**
   *
   * @type {number}
   * @memberof LearningPathPreview
   */
  id: number
}
/**
 *
 * @export
 * @interface PaginatedFeedSourceList
 */
export interface PaginatedFeedSourceList {
  /**
   *
   * @type {number}
   * @memberof PaginatedFeedSourceList
   */
  count?: number
  /**
   *
   * @type {string}
   * @memberof PaginatedFeedSourceList
   */
  next?: string | null
  /**
   *
   * @type {string}
   * @memberof PaginatedFeedSourceList
   */
  previous?: string | null
  /**
   *
   * @type {Array<FeedSource>}
   * @memberof PaginatedFeedSourceList
   */
  results?: Array<FeedSource>
}
/**
 *
 * @export
 * @interface PaginatedFieldChannelList
 */
export interface PaginatedFieldChannelList {
  /**
   *
   * @type {number}
   * @memberof PaginatedFieldChannelList
   */
  count?: number
  /**
   *
   * @type {string}
   * @memberof PaginatedFieldChannelList
   */
  next?: string | null
  /**
   *
   * @type {string}
   * @memberof PaginatedFieldChannelList
   */
  previous?: string | null
  /**
   *
   * @type {Array<FieldChannel>}
   * @memberof PaginatedFieldChannelList
   */
  results?: Array<FieldChannel>
}
/**
 * Similar to FieldChannelCreateSerializer, with read-only name
 * @export
 * @interface PatchedFieldChannelWriteRequest
 */
export interface PatchedFieldChannelWriteRequest {
  /**
   *
   * @type {string}
   * @memberof PatchedFieldChannelWriteRequest
   */
  title?: string
  /**
   *
   * @type {string}
   * @memberof PatchedFieldChannelWriteRequest
   */
  public_description?: string
  /**
   *
   * @type {Array<string>}
   * @memberof PatchedFieldChannelWriteRequest
   */
  subfields?: Array<string>
  /**
   * Learng path featured in this field.
   * @type {number}
   * @memberof PatchedFieldChannelWriteRequest
   */
  featured_list?: number | null
  /**
   * Learng paths in this field.
   * @type {Array<number>}
   * @memberof PatchedFieldChannelWriteRequest
   */
  lists?: Array<number>
  /**
   * Get the avatar image URL
   * @type {string}
   * @memberof PatchedFieldChannelWriteRequest
   */
  avatar?: string | null
  /**
   * Get the banner image URL
   * @type {string}
   * @memberof PatchedFieldChannelWriteRequest
   */
  banner?: string | null
  /**
   *
   * @type {any}
   * @memberof PatchedFieldChannelWriteRequest
   */
  about?: any | null
}
/**
 * Serializer for WidgetLists
 * @export
 * @interface PatchedWidgetListRequest
 */
export interface PatchedWidgetListRequest {
  /**
   *
   * @type {Array<WidgetInstance>}
   * @memberof PatchedWidgetListRequest
   */
  widgets?: Array<WidgetInstance> | null
}
/**
 * Serializer for Profile
 * @export
 * @interface Profile
 */
export interface Profile {
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  name?: string | null
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  image?: string | null
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  image_small?: string | null
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  image_medium?: string | null
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  image_file?: string | null
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  image_small_file?: string | null
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  image_medium_file?: string | null
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  profile_image_small: string
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  profile_image_medium: string
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  bio?: string | null
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  headline?: string | null
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  username: string
  /**
   *
   * @type {string}
   * @memberof Profile
   */
  placename: string
}
/**
 * Serializer for Subfields
 * @export
 * @interface Subfield
 */
export interface Subfield {
  /**
   *
   * @type {string}
   * @memberof Subfield
   */
  parent_field: string
  /**
   *
   * @type {string}
   * @memberof Subfield
   */
  field_channel: string
  /**
   *
   * @type {number}
   * @memberof Subfield
   */
  position?: number
}
/**
 * Serializer for User
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {number}
   * @memberof User
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string
  /**
   *
   * @type {Profile}
   * @memberof User
   */
  profile: Profile
  /**
   *
   * @type {string}
   * @memberof User
   */
  first_name: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  last_name: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  is_article_editor: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  is_learning_path_editor: string
}
/**
 * WidgetInstance serializer
 * @export
 * @interface WidgetInstance
 */
export interface WidgetInstance {
  /**
   *
   * @type {number}
   * @memberof WidgetInstance
   */
  id: number
  /**
   *
   * @type {WidgetTypeEnum}
   * @memberof WidgetInstance
   */
  widget_type: WidgetTypeEnum
  /**
   *
   * @type {string}
   * @memberof WidgetInstance
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof WidgetInstance
   */
  configuration?: string
  /**
   *
   * @type {string}
   * @memberof WidgetInstance
   */
  json: string
}

/**
 * Serializer for WidgetLists
 * @export
 * @interface WidgetList
 */
export interface WidgetList {
  /**
   *
   * @type {number}
   * @memberof WidgetList
   */
  id: number
  /**
   *
   * @type {Array<WidgetInstance>}
   * @memberof WidgetList
   */
  widgets?: Array<WidgetInstance> | null
  /**
   *
   * @type {Array<WidgetListAvailableWidgetsInner>}
   * @memberof WidgetList
   */
  available_widgets: Array<WidgetListAvailableWidgetsInner>
}
/**
 *
 * @export
 * @interface WidgetListAvailableWidgetsInner
 */
export interface WidgetListAvailableWidgetsInner {
  /**
   *
   * @type {string}
   * @memberof WidgetListAvailableWidgetsInner
   */
  widget_type?: string
  /**
   *
   * @type {string}
   * @memberof WidgetListAvailableWidgetsInner
   */
  description?: string
  /**
   *
   * @type {object}
   * @memberof WidgetListAvailableWidgetsInner
   */
  form_spec?: object
}
/**
 * Serializer for WidgetLists
 * @export
 * @interface WidgetListRequest
 */
export interface WidgetListRequest {
  /**
   *
   * @type {Array<WidgetInstance>}
   * @memberof WidgetListRequest
   */
  widgets?: Array<WidgetInstance> | null
}
/**
 * * `Markdown` - Markdown * `URL` - URL * `RSS Feed` - RSS Feed * `People` - People
 * @export
 * @enum {string}
 */

export const WidgetTypeEnum = {
  Markdown: "Markdown",
  Url: "URL",
  RssFeed: "RSS Feed",
  People: "People",
} as const

export type WidgetTypeEnum =
  (typeof WidgetTypeEnum)[keyof typeof WidgetTypeEnum]

/**
 * CkeditorApi - axios parameter creator
 * @export
 */
export const CkeditorApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get the JWT to authenticate for CKEditor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ckeditorRetrieve: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v0/ckeditor/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CkeditorApi - functional programming interface
 * @export
 */
export const CkeditorApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CkeditorApiAxiosParamCreator(configuration)
  return {
    /**
     * Get the JWT to authenticate for CKEditor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ckeditorRetrieve(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ckeditorRetrieve(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["CkeditorApi.ckeditorRetrieve"]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * CkeditorApi - factory interface
 * @export
 */
export const CkeditorApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CkeditorApiFp(configuration)
  return {
    /**
     * Get the JWT to authenticate for CKEditor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ckeditorRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .ckeditorRetrieve(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CkeditorApi - object-oriented interface
 * @export
 * @class CkeditorApi
 * @extends {BaseAPI}
 */
export class CkeditorApi extends BaseAPI {
  /**
   * Get the JWT to authenticate for CKEditor
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CkeditorApi
   */
  public ckeditorRetrieve(options?: RawAxiosRequestConfig) {
    return CkeditorApiFp(this.configuration)
      .ckeditorRetrieve(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FieldsApi - axios parameter creator
 * @export
 */
export const FieldsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary Create
     * @param {FieldChannelCreateRequest} FieldChannelCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsCreate: async (
      FieldChannelCreateRequest: FieldChannelCreateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'FieldChannelCreateRequest' is not null or undefined
      assertParamExists(
        "fieldsCreate",
        "FieldChannelCreateRequest",
        FieldChannelCreateRequest,
      )
      const localVarPath = `/api/v0/fields/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        FieldChannelCreateRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary Destroy
     * @param {string} field_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsDestroy: async (
      field_name: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'field_name' is not null or undefined
      assertParamExists("fieldsDestroy", "field_name", field_name)
      const localVarPath = `/api/v0/fields/{field_name}/`.replace(
        `{${"field_name"}}`,
        encodeURIComponent(String(field_name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary List
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsList: async (
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v0/fields/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * View for listing and adding moderators
     * @summary Field Moderators Create
     * @param {string} field_name
     * @param {FieldModeratorRequest} [FieldModeratorRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsModeratorsCreate: async (
      field_name: string,
      FieldModeratorRequest?: FieldModeratorRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'field_name' is not null or undefined
      assertParamExists("fieldsModeratorsCreate", "field_name", field_name)
      const localVarPath = `/api/v0/fields/{field_name}/moderators/`.replace(
        `{${"field_name"}}`,
        encodeURIComponent(String(field_name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        FieldModeratorRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Remove the user from the moderator groups for this website
     * @summary Field Moderators Destroy
     * @param {string} field_name
     * @param {string} moderator_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsModeratorsDestroy: async (
      field_name: string,
      moderator_name: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'field_name' is not null or undefined
      assertParamExists("fieldsModeratorsDestroy", "field_name", field_name)
      // verify required parameter 'moderator_name' is not null or undefined
      assertParamExists(
        "fieldsModeratorsDestroy",
        "moderator_name",
        moderator_name,
      )
      const localVarPath =
        `/api/v0/fields/{field_name}/moderators/{moderator_name}/`
          .replace(`{${"field_name"}}`, encodeURIComponent(String(field_name)))
          .replace(
            `{${"moderator_name"}}`,
            encodeURIComponent(String(moderator_name)),
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * View for listing and adding moderators
     * @summary Field Moderators List
     * @param {string} field_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsModeratorsList: async (
      field_name: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'field_name' is not null or undefined
      assertParamExists("fieldsModeratorsList", "field_name", field_name)
      const localVarPath = `/api/v0/fields/{field_name}/moderators/`.replace(
        `{${"field_name"}}`,
        encodeURIComponent(String(field_name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary Update
     * @param {string} field_name
     * @param {PatchedFieldChannelWriteRequest} [PatchedFieldChannelWriteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsPartialUpdate: async (
      field_name: string,
      PatchedFieldChannelWriteRequest?: PatchedFieldChannelWriteRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'field_name' is not null or undefined
      assertParamExists("fieldsPartialUpdate", "field_name", field_name)
      const localVarPath = `/api/v0/fields/{field_name}/`.replace(
        `{${"field_name"}}`,
        encodeURIComponent(String(field_name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        PatchedFieldChannelWriteRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary Retrieve
     * @param {string} field_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsRetrieve: async (
      field_name: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'field_name' is not null or undefined
      assertParamExists("fieldsRetrieve", "field_name", field_name)
      const localVarPath = `/api/v0/fields/{field_name}/`.replace(
        `{${"field_name"}}`,
        encodeURIComponent(String(field_name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FieldsApi - functional programming interface
 * @export
 */
export const FieldsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FieldsApiAxiosParamCreator(configuration)
  return {
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary Create
     * @param {FieldChannelCreateRequest} FieldChannelCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fieldsCreate(
      FieldChannelCreateRequest: FieldChannelCreateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FieldChannel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fieldsCreate(
        FieldChannelCreateRequest,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["FieldsApi.fieldsCreate"]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary Destroy
     * @param {string} field_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fieldsDestroy(
      field_name: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fieldsDestroy(
        field_name,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["FieldsApi.fieldsDestroy"]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary List
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fieldsList(
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PaginatedFieldChannelList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fieldsList(
        limit,
        offset,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["FieldsApi.fieldsList"]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * View for listing and adding moderators
     * @summary Field Moderators Create
     * @param {string} field_name
     * @param {FieldModeratorRequest} [FieldModeratorRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fieldsModeratorsCreate(
      field_name: string,
      FieldModeratorRequest?: FieldModeratorRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FieldModerator>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fieldsModeratorsCreate(
          field_name,
          FieldModeratorRequest,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["FieldsApi.fieldsModeratorsCreate"]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Remove the user from the moderator groups for this website
     * @summary Field Moderators Destroy
     * @param {string} field_name
     * @param {string} moderator_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fieldsModeratorsDestroy(
      field_name: string,
      moderator_name: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fieldsModeratorsDestroy(
          field_name,
          moderator_name,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["FieldsApi.fieldsModeratorsDestroy"]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * View for listing and adding moderators
     * @summary Field Moderators List
     * @param {string} field_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fieldsModeratorsList(
      field_name: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<FieldModerator>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fieldsModeratorsList(
          field_name,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["FieldsApi.fieldsModeratorsList"]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary Update
     * @param {string} field_name
     * @param {PatchedFieldChannelWriteRequest} [PatchedFieldChannelWriteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fieldsPartialUpdate(
      field_name: string,
      PatchedFieldChannelWriteRequest?: PatchedFieldChannelWriteRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FieldChannel>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fieldsPartialUpdate(
          field_name,
          PatchedFieldChannelWriteRequest,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["FieldsApi.fieldsPartialUpdate"]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary Retrieve
     * @param {string} field_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fieldsRetrieve(
      field_name: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FieldChannel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fieldsRetrieve(
        field_name,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["FieldsApi.fieldsRetrieve"]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * FieldsApi - factory interface
 * @export
 */
export const FieldsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FieldsApiFp(configuration)
  return {
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary Create
     * @param {FieldsApiFieldsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsCreate(
      requestParameters: FieldsApiFieldsCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<FieldChannel> {
      return localVarFp
        .fieldsCreate(requestParameters.FieldChannelCreateRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary Destroy
     * @param {FieldsApiFieldsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsDestroy(
      requestParameters: FieldsApiFieldsDestroyRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .fieldsDestroy(requestParameters.field_name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary List
     * @param {FieldsApiFieldsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsList(
      requestParameters: FieldsApiFieldsListRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaginatedFieldChannelList> {
      return localVarFp
        .fieldsList(requestParameters.limit, requestParameters.offset, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * View for listing and adding moderators
     * @summary Field Moderators Create
     * @param {FieldsApiFieldsModeratorsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsModeratorsCreate(
      requestParameters: FieldsApiFieldsModeratorsCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<FieldModerator> {
      return localVarFp
        .fieldsModeratorsCreate(
          requestParameters.field_name,
          requestParameters.FieldModeratorRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Remove the user from the moderator groups for this website
     * @summary Field Moderators Destroy
     * @param {FieldsApiFieldsModeratorsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsModeratorsDestroy(
      requestParameters: FieldsApiFieldsModeratorsDestroyRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .fieldsModeratorsDestroy(
          requestParameters.field_name,
          requestParameters.moderator_name,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * View for listing and adding moderators
     * @summary Field Moderators List
     * @param {FieldsApiFieldsModeratorsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsModeratorsList(
      requestParameters: FieldsApiFieldsModeratorsListRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<FieldModerator>> {
      return localVarFp
        .fieldsModeratorsList(requestParameters.field_name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary Update
     * @param {FieldsApiFieldsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsPartialUpdate(
      requestParameters: FieldsApiFieldsPartialUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<FieldChannel> {
      return localVarFp
        .fieldsPartialUpdate(
          requestParameters.field_name,
          requestParameters.PatchedFieldChannelWriteRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
     * @summary Retrieve
     * @param {FieldsApiFieldsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fieldsRetrieve(
      requestParameters: FieldsApiFieldsRetrieveRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<FieldChannel> {
      return localVarFp
        .fieldsRetrieve(requestParameters.field_name, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for fieldsCreate operation in FieldsApi.
 * @export
 * @interface FieldsApiFieldsCreateRequest
 */
export interface FieldsApiFieldsCreateRequest {
  /**
   *
   * @type {FieldChannelCreateRequest}
   * @memberof FieldsApiFieldsCreate
   */
  readonly FieldChannelCreateRequest: FieldChannelCreateRequest
}

/**
 * Request parameters for fieldsDestroy operation in FieldsApi.
 * @export
 * @interface FieldsApiFieldsDestroyRequest
 */
export interface FieldsApiFieldsDestroyRequest {
  /**
   *
   * @type {string}
   * @memberof FieldsApiFieldsDestroy
   */
  readonly field_name: string
}

/**
 * Request parameters for fieldsList operation in FieldsApi.
 * @export
 * @interface FieldsApiFieldsListRequest
 */
export interface FieldsApiFieldsListRequest {
  /**
   * Number of results to return per page.
   * @type {number}
   * @memberof FieldsApiFieldsList
   */
  readonly limit?: number

  /**
   * The initial index from which to return the results.
   * @type {number}
   * @memberof FieldsApiFieldsList
   */
  readonly offset?: number
}

/**
 * Request parameters for fieldsModeratorsCreate operation in FieldsApi.
 * @export
 * @interface FieldsApiFieldsModeratorsCreateRequest
 */
export interface FieldsApiFieldsModeratorsCreateRequest {
  /**
   *
   * @type {string}
   * @memberof FieldsApiFieldsModeratorsCreate
   */
  readonly field_name: string

  /**
   *
   * @type {FieldModeratorRequest}
   * @memberof FieldsApiFieldsModeratorsCreate
   */
  readonly FieldModeratorRequest?: FieldModeratorRequest
}

/**
 * Request parameters for fieldsModeratorsDestroy operation in FieldsApi.
 * @export
 * @interface FieldsApiFieldsModeratorsDestroyRequest
 */
export interface FieldsApiFieldsModeratorsDestroyRequest {
  /**
   *
   * @type {string}
   * @memberof FieldsApiFieldsModeratorsDestroy
   */
  readonly field_name: string

  /**
   *
   * @type {string}
   * @memberof FieldsApiFieldsModeratorsDestroy
   */
  readonly moderator_name: string
}

/**
 * Request parameters for fieldsModeratorsList operation in FieldsApi.
 * @export
 * @interface FieldsApiFieldsModeratorsListRequest
 */
export interface FieldsApiFieldsModeratorsListRequest {
  /**
   *
   * @type {string}
   * @memberof FieldsApiFieldsModeratorsList
   */
  readonly field_name: string
}

/**
 * Request parameters for fieldsPartialUpdate operation in FieldsApi.
 * @export
 * @interface FieldsApiFieldsPartialUpdateRequest
 */
export interface FieldsApiFieldsPartialUpdateRequest {
  /**
   *
   * @type {string}
   * @memberof FieldsApiFieldsPartialUpdate
   */
  readonly field_name: string

  /**
   *
   * @type {PatchedFieldChannelWriteRequest}
   * @memberof FieldsApiFieldsPartialUpdate
   */
  readonly PatchedFieldChannelWriteRequest?: PatchedFieldChannelWriteRequest
}

/**
 * Request parameters for fieldsRetrieve operation in FieldsApi.
 * @export
 * @interface FieldsApiFieldsRetrieveRequest
 */
export interface FieldsApiFieldsRetrieveRequest {
  /**
   *
   * @type {string}
   * @memberof FieldsApiFieldsRetrieve
   */
  readonly field_name: string
}

/**
 * FieldsApi - object-oriented interface
 * @export
 * @class FieldsApi
 * @extends {BaseAPI}
 */
export class FieldsApi extends BaseAPI {
  /**
   * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
   * @summary Create
   * @param {FieldsApiFieldsCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldsApi
   */
  public fieldsCreate(
    requestParameters: FieldsApiFieldsCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return FieldsApiFp(this.configuration)
      .fieldsCreate(requestParameters.FieldChannelCreateRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
   * @summary Destroy
   * @param {FieldsApiFieldsDestroyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldsApi
   */
  public fieldsDestroy(
    requestParameters: FieldsApiFieldsDestroyRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return FieldsApiFp(this.configuration)
      .fieldsDestroy(requestParameters.field_name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
   * @summary List
   * @param {FieldsApiFieldsListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldsApi
   */
  public fieldsList(
    requestParameters: FieldsApiFieldsListRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return FieldsApiFp(this.configuration)
      .fieldsList(requestParameters.limit, requestParameters.offset, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * View for listing and adding moderators
   * @summary Field Moderators Create
   * @param {FieldsApiFieldsModeratorsCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldsApi
   */
  public fieldsModeratorsCreate(
    requestParameters: FieldsApiFieldsModeratorsCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return FieldsApiFp(this.configuration)
      .fieldsModeratorsCreate(
        requestParameters.field_name,
        requestParameters.FieldModeratorRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Remove the user from the moderator groups for this website
   * @summary Field Moderators Destroy
   * @param {FieldsApiFieldsModeratorsDestroyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldsApi
   */
  public fieldsModeratorsDestroy(
    requestParameters: FieldsApiFieldsModeratorsDestroyRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return FieldsApiFp(this.configuration)
      .fieldsModeratorsDestroy(
        requestParameters.field_name,
        requestParameters.moderator_name,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * View for listing and adding moderators
   * @summary Field Moderators List
   * @param {FieldsApiFieldsModeratorsListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldsApi
   */
  public fieldsModeratorsList(
    requestParameters: FieldsApiFieldsModeratorsListRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return FieldsApiFp(this.configuration)
      .fieldsModeratorsList(requestParameters.field_name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
   * @summary Update
   * @param {FieldsApiFieldsPartialUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldsApi
   */
  public fieldsPartialUpdate(
    requestParameters: FieldsApiFieldsPartialUpdateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return FieldsApiFp(this.configuration)
      .fieldsPartialUpdate(
        requestParameters.field_name,
        requestParameters.PatchedFieldChannelWriteRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * CRUD Operations related to Fields. Fields may represent groups or organizations at MIT and are a high-level categorization of content.
   * @summary Retrieve
   * @param {FieldsApiFieldsRetrieveRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldsApi
   */
  public fieldsRetrieve(
    requestParameters: FieldsApiFieldsRetrieveRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return FieldsApiFp(this.configuration)
      .fieldsRetrieve(requestParameters.field_name, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * NewsEventsApi - axios parameter creator
 * @export
 */
export const NewsEventsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get a paginated list of feed items.
     * @param {Array<NewsEventsListFeedTypeEnum>} [feed_type] The type of item  * &#x60;news&#x60; - News * &#x60;events&#x60; - Events
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    newsEventsList: async (
      feed_type?: Array<NewsEventsListFeedTypeEnum>,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v0/news_events/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (feed_type) {
        localVarQueryParameter["feed_type"] = feed_type
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single feed item.
     * @param {number} id A unique integer value identifying this feed item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    newsEventsRetrieve: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("newsEventsRetrieve", "id", id)
      const localVarPath = `/api/v0/news_events/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * NewsEventsApi - functional programming interface
 * @export
 */
export const NewsEventsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    NewsEventsApiAxiosParamCreator(configuration)
  return {
    /**
     * Get a paginated list of feed items.
     * @param {Array<NewsEventsListFeedTypeEnum>} [feed_type] The type of item  * &#x60;news&#x60; - News * &#x60;events&#x60; - Events
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async newsEventsList(
      feed_type?: Array<NewsEventsListFeedTypeEnum>,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.newsEventsList(
        feed_type,
        limit,
        offset,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["NewsEventsApi.newsEventsList"]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Retrieve a single feed item.
     * @param {number} id A unique integer value identifying this feed item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async newsEventsRetrieve(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.newsEventsRetrieve(id, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["NewsEventsApi.newsEventsRetrieve"]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * NewsEventsApi - factory interface
 * @export
 */
export const NewsEventsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = NewsEventsApiFp(configuration)
  return {
    /**
     * Get a paginated list of feed items.
     * @param {NewsEventsApiNewsEventsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    newsEventsList(
      requestParameters: NewsEventsApiNewsEventsListRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .newsEventsList(
          requestParameters.feed_type,
          requestParameters.limit,
          requestParameters.offset,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single feed item.
     * @param {NewsEventsApiNewsEventsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    newsEventsRetrieve(
      requestParameters: NewsEventsApiNewsEventsRetrieveRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .newsEventsRetrieve(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for newsEventsList operation in NewsEventsApi.
 * @export
 * @interface NewsEventsApiNewsEventsListRequest
 */
export interface NewsEventsApiNewsEventsListRequest {
  /**
   * The type of item  * &#x60;news&#x60; - News * &#x60;events&#x60; - Events
   * @type {Array<'events' | 'news'>}
   * @memberof NewsEventsApiNewsEventsList
   */
  readonly feed_type?: Array<NewsEventsListFeedTypeEnum>

  /**
   * Number of results to return per page.
   * @type {number}
   * @memberof NewsEventsApiNewsEventsList
   */
  readonly limit?: number

  /**
   * The initial index from which to return the results.
   * @type {number}
   * @memberof NewsEventsApiNewsEventsList
   */
  readonly offset?: number
}

/**
 * Request parameters for newsEventsRetrieve operation in NewsEventsApi.
 * @export
 * @interface NewsEventsApiNewsEventsRetrieveRequest
 */
export interface NewsEventsApiNewsEventsRetrieveRequest {
  /**
   * A unique integer value identifying this feed item.
   * @type {number}
   * @memberof NewsEventsApiNewsEventsRetrieve
   */
  readonly id: number
}

/**
 * NewsEventsApi - object-oriented interface
 * @export
 * @class NewsEventsApi
 * @extends {BaseAPI}
 */
export class NewsEventsApi extends BaseAPI {
  /**
   * Get a paginated list of feed items.
   * @param {NewsEventsApiNewsEventsListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NewsEventsApi
   */
  public newsEventsList(
    requestParameters: NewsEventsApiNewsEventsListRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return NewsEventsApiFp(this.configuration)
      .newsEventsList(
        requestParameters.feed_type,
        requestParameters.limit,
        requestParameters.offset,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single feed item.
   * @param {NewsEventsApiNewsEventsRetrieveRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NewsEventsApi
   */
  public newsEventsRetrieve(
    requestParameters: NewsEventsApiNewsEventsRetrieveRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return NewsEventsApiFp(this.configuration)
      .newsEventsRetrieve(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const NewsEventsListFeedTypeEnum = {
  Events: "events",
  News: "news",
} as const
export type NewsEventsListFeedTypeEnum =
  (typeof NewsEventsListFeedTypeEnum)[keyof typeof NewsEventsListFeedTypeEnum]

/**
 * NewsEventsSourcesApi - axios parameter creator
 * @export
 */
export const NewsEventsSourcesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get a paginated list of news/event feed sources.
     * @param {Array<NewsEventsSourcesListFeedTypeEnum>} [feed_type] The type of source  * &#x60;news&#x60; - News * &#x60;events&#x60; - Events
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    newsEventsSourcesList: async (
      feed_type?: Array<NewsEventsSourcesListFeedTypeEnum>,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v0/news_events_sources/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (feed_type) {
        localVarQueryParameter["feed_type"] = feed_type
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single news/event feed source.
     * @param {number} id A unique integer value identifying this feed source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    newsEventsSourcesRetrieve: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("newsEventsSourcesRetrieve", "id", id)
      const localVarPath = `/api/v0/news_events_sources/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * NewsEventsSourcesApi - functional programming interface
 * @export
 */
export const NewsEventsSourcesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    NewsEventsSourcesApiAxiosParamCreator(configuration)
  return {
    /**
     * Get a paginated list of news/event feed sources.
     * @param {Array<NewsEventsSourcesListFeedTypeEnum>} [feed_type] The type of source  * &#x60;news&#x60; - News * &#x60;events&#x60; - Events
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async newsEventsSourcesList(
      feed_type?: Array<NewsEventsSourcesListFeedTypeEnum>,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PaginatedFeedSourceList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.newsEventsSourcesList(
          feed_type,
          limit,
          offset,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["NewsEventsSourcesApi.newsEventsSourcesList"]?.[
          index
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Retrieve a single news/event feed source.
     * @param {number} id A unique integer value identifying this feed source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async newsEventsSourcesRetrieve(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedSource>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.newsEventsSourcesRetrieve(id, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["NewsEventsSourcesApi.newsEventsSourcesRetrieve"]?.[
          index
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * NewsEventsSourcesApi - factory interface
 * @export
 */
export const NewsEventsSourcesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = NewsEventsSourcesApiFp(configuration)
  return {
    /**
     * Get a paginated list of news/event feed sources.
     * @param {NewsEventsSourcesApiNewsEventsSourcesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    newsEventsSourcesList(
      requestParameters: NewsEventsSourcesApiNewsEventsSourcesListRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaginatedFeedSourceList> {
      return localVarFp
        .newsEventsSourcesList(
          requestParameters.feed_type,
          requestParameters.limit,
          requestParameters.offset,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single news/event feed source.
     * @param {NewsEventsSourcesApiNewsEventsSourcesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    newsEventsSourcesRetrieve(
      requestParameters: NewsEventsSourcesApiNewsEventsSourcesRetrieveRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<FeedSource> {
      return localVarFp
        .newsEventsSourcesRetrieve(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for newsEventsSourcesList operation in NewsEventsSourcesApi.
 * @export
 * @interface NewsEventsSourcesApiNewsEventsSourcesListRequest
 */
export interface NewsEventsSourcesApiNewsEventsSourcesListRequest {
  /**
   * The type of source  * &#x60;news&#x60; - News * &#x60;events&#x60; - Events
   * @type {Array<'events' | 'news'>}
   * @memberof NewsEventsSourcesApiNewsEventsSourcesList
   */
  readonly feed_type?: Array<NewsEventsSourcesListFeedTypeEnum>

  /**
   * Number of results to return per page.
   * @type {number}
   * @memberof NewsEventsSourcesApiNewsEventsSourcesList
   */
  readonly limit?: number

  /**
   * The initial index from which to return the results.
   * @type {number}
   * @memberof NewsEventsSourcesApiNewsEventsSourcesList
   */
  readonly offset?: number
}

/**
 * Request parameters for newsEventsSourcesRetrieve operation in NewsEventsSourcesApi.
 * @export
 * @interface NewsEventsSourcesApiNewsEventsSourcesRetrieveRequest
 */
export interface NewsEventsSourcesApiNewsEventsSourcesRetrieveRequest {
  /**
   * A unique integer value identifying this feed source.
   * @type {number}
   * @memberof NewsEventsSourcesApiNewsEventsSourcesRetrieve
   */
  readonly id: number
}

/**
 * NewsEventsSourcesApi - object-oriented interface
 * @export
 * @class NewsEventsSourcesApi
 * @extends {BaseAPI}
 */
export class NewsEventsSourcesApi extends BaseAPI {
  /**
   * Get a paginated list of news/event feed sources.
   * @param {NewsEventsSourcesApiNewsEventsSourcesListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NewsEventsSourcesApi
   */
  public newsEventsSourcesList(
    requestParameters: NewsEventsSourcesApiNewsEventsSourcesListRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return NewsEventsSourcesApiFp(this.configuration)
      .newsEventsSourcesList(
        requestParameters.feed_type,
        requestParameters.limit,
        requestParameters.offset,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single news/event feed source.
   * @param {NewsEventsSourcesApiNewsEventsSourcesRetrieveRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NewsEventsSourcesApi
   */
  public newsEventsSourcesRetrieve(
    requestParameters: NewsEventsSourcesApiNewsEventsSourcesRetrieveRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return NewsEventsSourcesApiFp(this.configuration)
      .newsEventsSourcesRetrieve(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const NewsEventsSourcesListFeedTypeEnum = {
  Events: "events",
  News: "news",
} as const
export type NewsEventsSourcesListFeedTypeEnum =
  (typeof NewsEventsSourcesListFeedTypeEnum)[keyof typeof NewsEventsSourcesListFeedTypeEnum]

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * User retrieve and update viewsets for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersMeRetrieve: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v0/users/me/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
  return {
    /**
     * User retrieve and update viewsets for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersMeRetrieve(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersMeRetrieve(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["UsersApi.usersMeRetrieve"]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersApiFp(configuration)
  return {
    /**
     * User retrieve and update viewsets for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersMeRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<User> {
      return localVarFp
        .usersMeRetrieve(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * User retrieve and update viewsets for the current user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersMeRetrieve(options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .usersMeRetrieve(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * WidgetListsApi - axios parameter creator
 * @export
 */
export const WidgetListsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * API for managing widget lists
     * @param {number} id A unique integer value identifying this widget list.
     * @param {PatchedWidgetListRequest} [PatchedWidgetListRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    widgetListsPartialUpdate: async (
      id: number,
      PatchedWidgetListRequest?: PatchedWidgetListRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("widgetListsPartialUpdate", "id", id)
      const localVarPath = `/api/v0/widget_lists/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        PatchedWidgetListRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * API for managing widget lists
     * @param {number} id A unique integer value identifying this widget list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    widgetListsRetrieve: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("widgetListsRetrieve", "id", id)
      const localVarPath = `/api/v0/widget_lists/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * API for managing widget lists
     * @param {number} id A unique integer value identifying this widget list.
     * @param {WidgetListRequest} [WidgetListRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    widgetListsUpdate: async (
      id: number,
      WidgetListRequest?: WidgetListRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("widgetListsUpdate", "id", id)
      const localVarPath = `/api/v0/widget_lists/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        WidgetListRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WidgetListsApi - functional programming interface
 * @export
 */
export const WidgetListsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    WidgetListsApiAxiosParamCreator(configuration)
  return {
    /**
     * API for managing widget lists
     * @param {number} id A unique integer value identifying this widget list.
     * @param {PatchedWidgetListRequest} [PatchedWidgetListRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async widgetListsPartialUpdate(
      id: number,
      PatchedWidgetListRequest?: PatchedWidgetListRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WidgetList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.widgetListsPartialUpdate(
          id,
          PatchedWidgetListRequest,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["WidgetListsApi.widgetListsPartialUpdate"]?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * API for managing widget lists
     * @param {number} id A unique integer value identifying this widget list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async widgetListsRetrieve(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WidgetList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.widgetListsRetrieve(id, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["WidgetListsApi.widgetListsRetrieve"]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * API for managing widget lists
     * @param {number} id A unique integer value identifying this widget list.
     * @param {WidgetListRequest} [WidgetListRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async widgetListsUpdate(
      id: number,
      WidgetListRequest?: WidgetListRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WidgetList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.widgetListsUpdate(
          id,
          WidgetListRequest,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap["WidgetListsApi.widgetListsUpdate"]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * WidgetListsApi - factory interface
 * @export
 */
export const WidgetListsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WidgetListsApiFp(configuration)
  return {
    /**
     * API for managing widget lists
     * @param {WidgetListsApiWidgetListsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    widgetListsPartialUpdate(
      requestParameters: WidgetListsApiWidgetListsPartialUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WidgetList> {
      return localVarFp
        .widgetListsPartialUpdate(
          requestParameters.id,
          requestParameters.PatchedWidgetListRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * API for managing widget lists
     * @param {WidgetListsApiWidgetListsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    widgetListsRetrieve(
      requestParameters: WidgetListsApiWidgetListsRetrieveRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WidgetList> {
      return localVarFp
        .widgetListsRetrieve(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * API for managing widget lists
     * @param {WidgetListsApiWidgetListsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    widgetListsUpdate(
      requestParameters: WidgetListsApiWidgetListsUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WidgetList> {
      return localVarFp
        .widgetListsUpdate(
          requestParameters.id,
          requestParameters.WidgetListRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for widgetListsPartialUpdate operation in WidgetListsApi.
 * @export
 * @interface WidgetListsApiWidgetListsPartialUpdateRequest
 */
export interface WidgetListsApiWidgetListsPartialUpdateRequest {
  /**
   * A unique integer value identifying this widget list.
   * @type {number}
   * @memberof WidgetListsApiWidgetListsPartialUpdate
   */
  readonly id: number

  /**
   *
   * @type {PatchedWidgetListRequest}
   * @memberof WidgetListsApiWidgetListsPartialUpdate
   */
  readonly PatchedWidgetListRequest?: PatchedWidgetListRequest
}

/**
 * Request parameters for widgetListsRetrieve operation in WidgetListsApi.
 * @export
 * @interface WidgetListsApiWidgetListsRetrieveRequest
 */
export interface WidgetListsApiWidgetListsRetrieveRequest {
  /**
   * A unique integer value identifying this widget list.
   * @type {number}
   * @memberof WidgetListsApiWidgetListsRetrieve
   */
  readonly id: number
}

/**
 * Request parameters for widgetListsUpdate operation in WidgetListsApi.
 * @export
 * @interface WidgetListsApiWidgetListsUpdateRequest
 */
export interface WidgetListsApiWidgetListsUpdateRequest {
  /**
   * A unique integer value identifying this widget list.
   * @type {number}
   * @memberof WidgetListsApiWidgetListsUpdate
   */
  readonly id: number

  /**
   *
   * @type {WidgetListRequest}
   * @memberof WidgetListsApiWidgetListsUpdate
   */
  readonly WidgetListRequest?: WidgetListRequest
}

/**
 * WidgetListsApi - object-oriented interface
 * @export
 * @class WidgetListsApi
 * @extends {BaseAPI}
 */
export class WidgetListsApi extends BaseAPI {
  /**
   * API for managing widget lists
   * @param {WidgetListsApiWidgetListsPartialUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WidgetListsApi
   */
  public widgetListsPartialUpdate(
    requestParameters: WidgetListsApiWidgetListsPartialUpdateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return WidgetListsApiFp(this.configuration)
      .widgetListsPartialUpdate(
        requestParameters.id,
        requestParameters.PatchedWidgetListRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * API for managing widget lists
   * @param {WidgetListsApiWidgetListsRetrieveRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WidgetListsApi
   */
  public widgetListsRetrieve(
    requestParameters: WidgetListsApiWidgetListsRetrieveRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return WidgetListsApiFp(this.configuration)
      .widgetListsRetrieve(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * API for managing widget lists
   * @param {WidgetListsApiWidgetListsUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WidgetListsApi
   */
  public widgetListsUpdate(
    requestParameters: WidgetListsApiWidgetListsUpdateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return WidgetListsApiFp(this.configuration)
      .widgetListsUpdate(
        requestParameters.id,
        requestParameters.WidgetListRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

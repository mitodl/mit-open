/* tslint:disable */
/* eslint-disable */
/**
 * MIT Open Discussions Course Catalog API
 * Open Discussions public API
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration"
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios"
import globalAxios from "axios"
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction
} from "./common"
import type { RequestArgs } from "./base"
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from "./base"

/**
 * Serializer for CourseTopic model
 * @export
 * @interface CourseTopic
 */
export interface CourseTopic {
  /**
   *
   * @type {number}
   * @memberof CourseTopic
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof CourseTopic
   */
  name: string
}
/**
 * Serializer for FieldChannel
 * @export
 * @interface FieldChannel
 */
export interface FieldChannel {
  /**
   *
   * @type {string}
   * @memberof FieldChannel
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof FieldChannel
   */
  title: string
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof FieldChannel
   */
  about: { [key: string]: any } | null
  /**
   *
   * @type {string}
   * @memberof FieldChannel
   */
  public_description: string
  /**
   *
   * @type {Array<Subfield>}
   * @memberof FieldChannel
   */
  subfields: Array<Subfield>
  /**
   *
   * @type {UserList}
   * @memberof FieldChannel
   */
  featured_list: UserList
  /**
   *
   * @type {Array<UserList>}
   * @memberof FieldChannel
   */
  lists: Array<UserList>
  /**
   * Get the avatar image URL
   * @type {string}
   * @memberof FieldChannel
   */
  avatar?: string
  /**
   * Get the avatar image medium URL
   * @type {string}
   * @memberof FieldChannel
   */
  avatar_medium: string
  /**
   * Get the avatar image small URL
   * @type {string}
   * @memberof FieldChannel
   */
  avatar_small: string
  /**
   * Get the banner image URL
   * @type {string}
   * @memberof FieldChannel
   */
  banner?: string
  /**
   *
   * @type {number}
   * @memberof FieldChannel
   */
  widget_list: number | null
  /**
   *
   * @type {string}
   * @memberof FieldChannel
   */
  updated_on: string
  /**
   *
   * @type {string}
   * @memberof FieldChannel
   */
  created_on: string
  /**
   *
   * @type {number}
   * @memberof FieldChannel
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof FieldChannel
   */
  ga_tracking_id: string | null
  /**
   * Return true if user is a moderator for the channel
   * @type {boolean}
   * @memberof FieldChannel
   */
  is_moderator: boolean
}
/**
 * Write serializer for FieldChannel
 * @export
 * @interface FieldChannelCreate
 */
export interface FieldChannelCreate {
  /**
   *
   * @type {string}
   * @memberof FieldChannelCreate
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof FieldChannelCreate
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof FieldChannelCreate
   */
  public_description?: string
  /**
   *
   * @type {Array<Subfield>}
   * @memberof FieldChannelCreate
   */
  subfields?: Array<Subfield>
  /**
   *
   * @type {number}
   * @memberof FieldChannelCreate
   */
  featured_list?: number | null
  /**
   *
   * @type {Array<UserList>}
   * @memberof FieldChannelCreate
   */
  lists?: Array<UserList>
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof FieldChannelCreate
   */
  about?: { [key: string]: any } | null
}
/**
 * Similar to FieldChannelCreateSerializer, with read-only name
 * @export
 * @interface FieldChannelWrite
 */
export interface FieldChannelWrite {
  /**
   *
   * @type {string}
   * @memberof FieldChannelWrite
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof FieldChannelWrite
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof FieldChannelWrite
   */
  public_description?: string
  /**
   *
   * @type {Array<Subfield>}
   * @memberof FieldChannelWrite
   */
  subfields?: Array<Subfield>
  /**
   *
   * @type {number}
   * @memberof FieldChannelWrite
   */
  featured_list?: number | null
  /**
   *
   * @type {Array<UserList>}
   * @memberof FieldChannelWrite
   */
  lists?: Array<UserList>
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof FieldChannelWrite
   */
  about?: { [key: string]: any } | null
  /**
   * Get the avatar image URL
   * @type {string}
   * @memberof FieldChannelWrite
   */
  avatar?: string
  /**
   * Get the banner image URL
   * @type {string}
   * @memberof FieldChannelWrite
   */
  banner?: string
}
/**
 * Serializer for moderators
 * @export
 * @interface FieldModerator
 */
export interface FieldModerator {
  /**
   * Returns the name for the moderator
   * @type {string}
   * @memberof FieldModerator
   */
  moderator_name?: string
  /**
   * Get the email from the associated user
   * @type {string}
   * @memberof FieldModerator
   */
  email?: string
  /**
   * Get the full name of the associated user
   * @type {string}
   * @memberof FieldModerator
   */
  full_name: string
}
/**
 * Serializer for UserListItem containing only the item id and userlist id.
 * @export
 * @interface MicroStaffListItem
 */
export interface MicroStaffListItem {
  /**
   *
   * @type {number}
   * @memberof MicroStaffListItem
   */
  item_id: number
  /**
   *
   * @type {number}
   * @memberof MicroStaffListItem
   */
  list_id: number
  /**
   *
   * @type {number}
   * @memberof MicroStaffListItem
   */
  object_id: number
  /**
   *
   * @type {string}
   * @memberof MicroStaffListItem
   */
  content_type: string
}
/**
 * Serializer for UserListItem containing only the item id and userlist id.
 * @export
 * @interface MicroUserListItem
 */
export interface MicroUserListItem {
  /**
   *
   * @type {number}
   * @memberof MicroUserListItem
   */
  item_id: number
  /**
   *
   * @type {number}
   * @memberof MicroUserListItem
   */
  list_id: number
  /**
   *
   * @type {number}
   * @memberof MicroUserListItem
   */
  object_id: number
  /**
   *
   * @type {string}
   * @memberof MicroUserListItem
   */
  content_type: string
}
/**
 *
 * @export
 * @interface PaginatedFieldChannelList
 */
export interface PaginatedFieldChannelList {
  /**
   *
   * @type {number}
   * @memberof PaginatedFieldChannelList
   */
  count?: number
  /**
   *
   * @type {string}
   * @memberof PaginatedFieldChannelList
   */
  next?: string | null
  /**
   *
   * @type {string}
   * @memberof PaginatedFieldChannelList
   */
  previous?: string | null
  /**
   *
   * @type {Array<FieldChannel>}
   * @memberof PaginatedFieldChannelList
   */
  results?: Array<FieldChannel>
}
/**
 * Similar to FieldChannelCreateSerializer, with read-only name
 * @export
 * @interface PatchedFieldChannelWrite
 */
export interface PatchedFieldChannelWrite {
  /**
   *
   * @type {string}
   * @memberof PatchedFieldChannelWrite
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof PatchedFieldChannelWrite
   */
  title?: string
  /**
   *
   * @type {string}
   * @memberof PatchedFieldChannelWrite
   */
  public_description?: string
  /**
   *
   * @type {Array<Subfield>}
   * @memberof PatchedFieldChannelWrite
   */
  subfields?: Array<Subfield>
  /**
   *
   * @type {number}
   * @memberof PatchedFieldChannelWrite
   */
  featured_list?: number | null
  /**
   *
   * @type {Array<UserList>}
   * @memberof PatchedFieldChannelWrite
   */
  lists?: Array<UserList>
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof PatchedFieldChannelWrite
   */
  about?: { [key: string]: any } | null
  /**
   * Get the avatar image URL
   * @type {string}
   * @memberof PatchedFieldChannelWrite
   */
  avatar?: string
  /**
   * Get the banner image URL
   * @type {string}
   * @memberof PatchedFieldChannelWrite
   */
  banner?: string
}
/**
 * Serializer for Subfields
 * @export
 * @interface Subfield
 */
export interface Subfield {
  /**
   *
   * @type {string}
   * @memberof Subfield
   */
  parent_field: string
  /**
   *
   * @type {string}
   * @memberof Subfield
   */
  field_channel: string
  /**
   *
   * @type {number}
   * @memberof Subfield
   */
  position?: number
}
/**
 * Simplified serializer for UserList model.
 * @export
 * @interface UserList
 */
export interface UserList {
  /**
   *
   * @type {number}
   * @memberof UserList
   */
  id: number
  /**
   * Return the number of items in the list
   * @type {number}
   * @memberof UserList
   */
  item_count: number
  /**
   *
   * @type {Array<CourseTopic>}
   * @memberof UserList
   */
  topics?: Array<CourseTopic>
  /**
   * get author name for userlist
   * @type {string}
   * @memberof UserList
   */
  author_name: string
  /**
   *
   * @type {string}
   * @memberof UserList
   */
  object_type: string
  /**
   * Return the user list\'s image or the image of the first item
   * @type {string}
   * @memberof UserList
   */
  image_src: string
  /**
   * Returns the audience for the user list
   * @type {Array<string>}
   * @memberof UserList
   */
  audience: Array<string>
  /**
   * Returns the certification for the user list
   * @type {Array<string>}
   * @memberof UserList
   */
  certification: Array<string>
  /**
   *
   * @type {boolean}
   * @memberof UserList
   */
  is_favorite: boolean
  /**
   *
   * @type {Array<MicroUserListItem>}
   * @memberof UserList
   */
  lists: Array<MicroUserListItem>
  /**
   *
   * @type {Array<MicroStaffListItem>}
   * @memberof UserList
   */
  stafflists: Array<MicroStaffListItem>
  /**
   *
   * @type {string}
   * @memberof UserList
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof UserList
   */
  short_description?: string | null
  /**
   *
   * @type {string}
   * @memberof UserList
   */
  image_description?: string | null
  /**
   *
   * @type {string}
   * @memberof UserList
   */
  privacy_level?: string
  /**
   *
   * @type {string}
   * @memberof UserList
   */
  list_type: string
  /**
   *
   * @type {number}
   * @memberof UserList
   */
  author: number
  /**
   *
   * @type {Array<number>}
   * @memberof UserList
   */
  offered_by?: Array<number>
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Viewset for Field Channels
     * @param {FieldChannelCreate} fieldChannelCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootCreate: async (
      fieldChannelCreate: FieldChannelCreate,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fieldChannelCreate' is not null or undefined
      assertParamExists("rootCreate", "fieldChannelCreate", fieldChannelCreate)
      const localVarPath = `/api/v0/fields/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cookieAuth required

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        fieldChannelCreate,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Viewset for Field Channels
     * @param {string} fieldName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootDestroy: async (
      fieldName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fieldName' is not null or undefined
      assertParamExists("rootDestroy", "fieldName", fieldName)
      const localVarPath = `/api/v0/fields/{field_name}/`.replace(
        `{${"field_name"}}`,
        encodeURIComponent(String(fieldName))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cookieAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Viewset for Field Channels
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootList: async (
      limit?: number,
      offset?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v0/fields/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cookieAuth required

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Viewset for Field Channels
     * @param {string} fieldName
     * @param {PatchedFieldChannelWrite} [patchedFieldChannelWrite]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootPartialUpdate: async (
      fieldName: string,
      patchedFieldChannelWrite?: PatchedFieldChannelWrite,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fieldName' is not null or undefined
      assertParamExists("rootPartialUpdate", "fieldName", fieldName)
      const localVarPath = `/api/v0/fields/{field_name}/`.replace(
        `{${"field_name"}}`,
        encodeURIComponent(String(fieldName))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cookieAuth required

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchedFieldChannelWrite,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Viewset for Field Channels
     * @param {string} fieldName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootRetrieve: async (
      fieldName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fieldName' is not null or undefined
      assertParamExists("rootRetrieve", "fieldName", fieldName)
      const localVarPath = `/api/v0/fields/{field_name}/`.replace(
        `{${"field_name"}}`,
        encodeURIComponent(String(fieldName))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cookieAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Viewset for Field Channels
     * @param {string} fieldName
     * @param {FieldChannelWrite} fieldChannelWrite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootUpdate: async (
      fieldName: string,
      fieldChannelWrite: FieldChannelWrite,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fieldName' is not null or undefined
      assertParamExists("rootUpdate", "fieldName", fieldName)
      // verify required parameter 'fieldChannelWrite' is not null or undefined
      assertParamExists("rootUpdate", "fieldChannelWrite", fieldChannelWrite)
      const localVarPath = `/api/v0/fields/{field_name}/`.replace(
        `{${"field_name"}}`,
        encodeURIComponent(String(fieldName))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cookieAuth required

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        fieldChannelWrite,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * Viewset for Field Channels
     * @param {FieldChannelCreate} fieldChannelCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rootCreate(
      fieldChannelCreate: FieldChannelCreate,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<FieldChannelCreate>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rootCreate(
        fieldChannelCreate,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Viewset for Field Channels
     * @param {string} fieldName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rootDestroy(
      fieldName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rootDestroy(
        fieldName,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Viewset for Field Channels
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rootList(
      limit?: number,
      offset?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PaginatedFieldChannelList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rootList(
        limit,
        offset,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Viewset for Field Channels
     * @param {string} fieldName
     * @param {PatchedFieldChannelWrite} [patchedFieldChannelWrite]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rootPartialUpdate(
      fieldName: string,
      patchedFieldChannelWrite?: PatchedFieldChannelWrite,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<FieldChannelWrite>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.rootPartialUpdate(
          fieldName,
          patchedFieldChannelWrite,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Viewset for Field Channels
     * @param {string} fieldName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rootRetrieve(
      fieldName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FieldChannel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rootRetrieve(
        fieldName,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Viewset for Field Channels
     * @param {string} fieldName
     * @param {FieldChannelWrite} fieldChannelWrite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rootUpdate(
      fieldName: string,
      fieldChannelWrite: FieldChannelWrite,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<FieldChannelWrite>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rootUpdate(
        fieldName,
        fieldChannelWrite,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * Viewset for Field Channels
     * @param {FieldChannelCreate} fieldChannelCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootCreate(
      fieldChannelCreate: FieldChannelCreate,
      options?: any
    ): AxiosPromise<FieldChannelCreate> {
      return localVarFp
        .rootCreate(fieldChannelCreate, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Viewset for Field Channels
     * @param {string} fieldName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootDestroy(fieldName: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .rootDestroy(fieldName, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Viewset for Field Channels
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootList(
      limit?: number,
      offset?: number,
      options?: any
    ): AxiosPromise<PaginatedFieldChannelList> {
      return localVarFp
        .rootList(limit, offset, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Viewset for Field Channels
     * @param {string} fieldName
     * @param {PatchedFieldChannelWrite} [patchedFieldChannelWrite]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootPartialUpdate(
      fieldName: string,
      patchedFieldChannelWrite?: PatchedFieldChannelWrite,
      options?: any
    ): AxiosPromise<FieldChannelWrite> {
      return localVarFp
        .rootPartialUpdate(fieldName, patchedFieldChannelWrite, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Viewset for Field Channels
     * @param {string} fieldName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootRetrieve(fieldName: string, options?: any): AxiosPromise<FieldChannel> {
      return localVarFp
        .rootRetrieve(fieldName, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Viewset for Field Channels
     * @param {string} fieldName
     * @param {FieldChannelWrite} fieldChannelWrite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootUpdate(
      fieldName: string,
      fieldChannelWrite: FieldChannelWrite,
      options?: any
    ): AxiosPromise<FieldChannelWrite> {
      return localVarFp
        .rootUpdate(fieldName, fieldChannelWrite, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Viewset for Field Channels
   * @param {FieldChannelCreate} fieldChannelCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public rootCreate(
    fieldChannelCreate: FieldChannelCreate,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .rootCreate(fieldChannelCreate, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Viewset for Field Channels
   * @param {string} fieldName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public rootDestroy(fieldName: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .rootDestroy(fieldName, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Viewset for Field Channels
   * @param {number} [limit] Number of results to return per page.
   * @param {number} [offset] The initial index from which to return the results.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public rootList(
    limit?: number,
    offset?: number,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .rootList(limit, offset, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Viewset for Field Channels
   * @param {string} fieldName
   * @param {PatchedFieldChannelWrite} [patchedFieldChannelWrite]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public rootPartialUpdate(
    fieldName: string,
    patchedFieldChannelWrite?: PatchedFieldChannelWrite,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .rootPartialUpdate(fieldName, patchedFieldChannelWrite, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Viewset for Field Channels
   * @param {string} fieldName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public rootRetrieve(fieldName: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .rootRetrieve(fieldName, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Viewset for Field Channels
   * @param {string} fieldName
   * @param {FieldChannelWrite} fieldChannelWrite
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public rootUpdate(
    fieldName: string,
    fieldChannelWrite: FieldChannelWrite,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .rootUpdate(fieldName, fieldChannelWrite, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * ModeratorsApi - axios parameter creator
 * @export
 */
export const ModeratorsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * View for listing and adding moderators
     * @param {string} fieldName
     * @param {FieldModerator} [fieldModerator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moderatorsCreate: async (
      fieldName: string,
      fieldModerator?: FieldModerator,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fieldName' is not null or undefined
      assertParamExists("moderatorsCreate", "fieldName", fieldName)
      const localVarPath = `/api/v0/fields/{field_name}/moderators/`.replace(
        `{${"field_name"}}`,
        encodeURIComponent(String(fieldName))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cookieAuth required

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        fieldModerator,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Remove the user from the moderator groups for this website
     * @param {string} fieldName
     * @param {string} moderatorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moderatorsDestroy: async (
      fieldName: string,
      moderatorName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fieldName' is not null or undefined
      assertParamExists("moderatorsDestroy", "fieldName", fieldName)
      // verify required parameter 'moderatorName' is not null or undefined
      assertParamExists("moderatorsDestroy", "moderatorName", moderatorName)
      const localVarPath =
        `/api/v0/fields/{field_name}/moderators/{moderator_name}/`
          .replace(`{${"field_name"}}`, encodeURIComponent(String(fieldName)))
          .replace(
            `{${"moderator_name"}}`,
            encodeURIComponent(String(moderatorName))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cookieAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * View for listing and adding moderators
     * @param {string} fieldName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moderatorsList: async (
      fieldName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fieldName' is not null or undefined
      assertParamExists("moderatorsList", "fieldName", fieldName)
      const localVarPath = `/api/v0/fields/{field_name}/moderators/`.replace(
        `{${"field_name"}}`,
        encodeURIComponent(String(fieldName))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cookieAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * ModeratorsApi - functional programming interface
 * @export
 */
export const ModeratorsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ModeratorsApiAxiosParamCreator(configuration)
  return {
    /**
     * View for listing and adding moderators
     * @param {string} fieldName
     * @param {FieldModerator} [fieldModerator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moderatorsCreate(
      fieldName: string,
      fieldModerator?: FieldModerator,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FieldModerator>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.moderatorsCreate(
          fieldName,
          fieldModerator,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Remove the user from the moderator groups for this website
     * @param {string} fieldName
     * @param {string} moderatorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moderatorsDestroy(
      fieldName: string,
      moderatorName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.moderatorsDestroy(
          fieldName,
          moderatorName,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * View for listing and adding moderators
     * @param {string} fieldName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moderatorsList(
      fieldName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<FieldModerator>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.moderatorsList(
        fieldName,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * ModeratorsApi - factory interface
 * @export
 */
export const ModeratorsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ModeratorsApiFp(configuration)
  return {
    /**
     * View for listing and adding moderators
     * @param {string} fieldName
     * @param {FieldModerator} [fieldModerator]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moderatorsCreate(
      fieldName: string,
      fieldModerator?: FieldModerator,
      options?: any
    ): AxiosPromise<FieldModerator> {
      return localVarFp
        .moderatorsCreate(fieldName, fieldModerator, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Remove the user from the moderator groups for this website
     * @param {string} fieldName
     * @param {string} moderatorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moderatorsDestroy(
      fieldName: string,
      moderatorName: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .moderatorsDestroy(fieldName, moderatorName, options)
        .then(request => request(axios, basePath))
    },
    /**
     * View for listing and adding moderators
     * @param {string} fieldName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moderatorsList(
      fieldName: string,
      options?: any
    ): AxiosPromise<Array<FieldModerator>> {
      return localVarFp
        .moderatorsList(fieldName, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * ModeratorsApi - object-oriented interface
 * @export
 * @class ModeratorsApi
 * @extends {BaseAPI}
 */
export class ModeratorsApi extends BaseAPI {
  /**
   * View for listing and adding moderators
   * @param {string} fieldName
   * @param {FieldModerator} [fieldModerator]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModeratorsApi
   */
  public moderatorsCreate(
    fieldName: string,
    fieldModerator?: FieldModerator,
    options?: AxiosRequestConfig
  ) {
    return ModeratorsApiFp(this.configuration)
      .moderatorsCreate(fieldName, fieldModerator, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Remove the user from the moderator groups for this website
   * @param {string} fieldName
   * @param {string} moderatorName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModeratorsApi
   */
  public moderatorsDestroy(
    fieldName: string,
    moderatorName: string,
    options?: AxiosRequestConfig
  ) {
    return ModeratorsApiFp(this.configuration)
      .moderatorsDestroy(fieldName, moderatorName, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * View for listing and adding moderators
   * @param {string} fieldName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModeratorsApi
   */
  public moderatorsList(fieldName: string, options?: AxiosRequestConfig) {
    return ModeratorsApiFp(this.configuration)
      .moderatorsList(fieldName, options)
      .then(request => request(this.axios, this.basePath))
  }
}


const foo = new DefaultApi()